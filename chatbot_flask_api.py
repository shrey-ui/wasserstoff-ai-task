from flask import Flask, request, jsonify, make_response
from flask_cors import CORS, cross_origin
import json
import requests
import os
from src import RAG_gen
from src import gen_vector_db
import pickle

app_chatbot = Flask(__name__)

#If there is any OPTIONS request

def build_cors_preflight_response():
	response = make_response()
	response.headers.add("Access-Control-Allow-Origin", "*")
	response.headers.add("Access-Control-Allow-Headers", "*")
	response.headers.add("Access-Control-Allow-Methods", "*")

	return response

def build_cors_actual_response(response):
    response.headers.add("Access-Control-Allow-Origin", "*")
    return response

# Loads DB Instances saved if Flask Server crashes

try:
	with open("db_list.pkl", 'rb') as db_list_pkl:
		website_db = pickle.load(db_list_pkl)
except Exception as e:
	print(f"{e}")
	website_db = {}
	print("Initializing API")


#Endpoint to be called for updation of Vector Embeddings when New Post Published.
# Will be automatically called due to the WordPress Hook/Plugin created

@app_chatbot.route('/update-vector-db', methods = ["POST"])
def update_vector_db():
	
	try:
		if request.content_type != "application/json":
			return build_cors_actual_response(make_response(jsonify({"error": "Content-type must be application/json"})))

		print(request.method)
		# referer= request.headers.get("Referer")
		# if not referer:
		# 	return jsonify({"error" : "No Referer found"}), 400

		post_data = request.get_json()
		wordpress_site_url = post_data.get('site_url')
		post_title = post_data.get('post_title' , '')
		post_cont = post_data.get('post_content', '')

		combined_content = f"{post_title} {post_cont}"

		# wordpress_site_url = referer.split('/')[2]
		# wordpress_site_url = f"http://{wordpress_site_url}"

		if wordpress_site_url in website_db:
			website_db[wordpress_site_url].add_to_vector_db(combined_content)

		return jsonify({"message" : "Vector DB Update was successful - Embeddings Created & Added"}), 200		

	except Exception as e:
		return jsonify({"message": f"Error - Vector DB update was unsuccessful - {e}"}), 500


#Endpoint to handle the chatbot itself.
#If the request is originating from a new WordPress site never seen before
#then embeddings will be generated by downloading all the posts
#If WordPress is seen before/embeddings are present - Query response will be 
#given immediately



@app_chatbot.route('/chatbot' , methods = ['POST', 'OPTIONS'])
def chatbot():
	if request.method == "OPTIONS" : 
		print(request.method)
		return build_cors_preflight_response()
	elif request.method == "POST":
		
	
		if request.content_type != "application/json":
			
			return build_cors_actual_response(make_response(jsonify({"error": "Content-type must be application/json"})))

		print(request.method)

		print(request.get_json())
		wordpress_site = request.get_json()['wordpress_link']
		query = request.get_json()['query']
		if wordpress_site not in website_db:
			embedding_model = "Alibaba-NLP/gte-large-en-v1.5"
			chunk_size= 256

			print("New Website Detected - Creating Embeddings")
			db = gen_vector_db.FAISSVectorDB(wordpress_site, embedding_model, chunk_size)
			db.init_vector_db()
			website_db[wordpress_site] = db

			# if WordPress is running locally, then localhost + port is added to seen 
			# before WordPress sites as it is the same thing

			if ".local" in wordpress_site:
				wordpress_port = wordpress_site.split(".local:")[1]
				website_db[f"http://localhost:{wordpress_port}"] = db

			# Saving seen websites and corresponding Vector DB's 
			# (this has not been implemented yet. Issues with Class DB 
			# pickling due to Transformer library were seen)
			with open("db_list.pkl" , 'wb') as db_list_pkl_save:
				pickle.dump(website_db, db_list_pkl_save)


		db_to_get= website_db[wordpress_site]
		
		if query != "":
			similar_posts = gen_vector_db.find_simposts_in_db(db_to_get, query, 10)
			response = RAG_gen.generate_rag_response(db_to_get, query, similar_posts)

			json_resp = jsonify({"chatbot_response" : response})
			print(json_resp)
			return json_resp
		else:
			json_resp = json.dumps({"chatbot_response" : "Please check your query. It is not what I expected!"})
			return json_resp


if __name__ == "__main__":
	#Using Waitress to actually serve - a WSGI Application running a Flask App.
	from waitress import serve
	serve(app_chatbot, host= 'localhost', port = 5001)